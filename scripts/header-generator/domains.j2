#pragma once

#include <optional>

#include <nlohmann/json.hpp>

#include "../HAEntity.hpp"

using json = nlohmann::json;
using std::optional;

#if 0
enum class EntityType
{
{%- for domain in result.keys() %}
  {{ domain | title }},
{%- endfor %}
  OTHER,
};
#endif

namespace HADomains
{
{% for domain, services in result.items() %}
// START HEADER FOR {{ domain | title }}

class {{ domain | title }}
{
public:
  {{ domain | title }}(std::shared_ptr<HAEntity> entity) :
    entity(entity) {}

  // const EntityType __domain = EntityType::{{ domain | title }};
{%- for name, desc in services.items() %}
  // {{ desc.name }}
  // {{ desc.description }}
  struct {{ name }}_args
  {
{%- for field in desc.fields.keys() %}
    optional<json> {{ field }};
{%- endfor %}
  };
  void {% if name == 'delete' %}_{% endif %}{{ name }}([[maybe_unused]] const {{ name }}_args& args)
  {
    json cmd;

    cmd["type"] = "call_service";
    cmd["domain"] = "{{ domain }}";
    cmd["service"] = "{{ name }}";
    cmd["target"]["entity_id"] = entity->id;

{%- for field in desc.fields.keys() %}
    if (args.{{ field }}) {
      cmd["service_data"]["{{ field }}"] = *args.{{ field }};
    }
{%- endfor %}

    entity->WSConnSend(cmd);
  }
{% endfor %}
private:
  std::shared_ptr<HAEntity> entity;
};
{% endfor %}
}
